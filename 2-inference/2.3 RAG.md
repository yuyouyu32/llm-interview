# RAG (Retrieval-Augmented Generation)
> 本章介绍面试中关于 RAG 的常见问题，涵盖基本概念、架构设计、实现细节及应用场景。

## 1. Training

### Q. RAG中Retriever和Generator分别怎么做微调？
**Company**: 蔚来 ｜ **Round**: 算法工程师 一面 ｜ **Date**: 2025-07-15 ｜ **Tags**: [RAG, Retriever, Generator, 微调]

**1. 背景问题**  
- RAG (Retrieval-Augmented Generation) 框架由 **Retriever**（检索器）和 **Generator**（生成器）两部分组成。  
- Retriever 负责从知识库中找出相关文档，Generator 负责基于检索到的文档和原始查询生成答案。  
- 如何分别对这两个模块进行微调，是 RAG 落地的关键。

**2. Retriever 的微调方式**  
1. **双塔 (Bi-Encoder) 微调**  
   - 通常使用 **对比学习 (Contrastive Learning)**：让 query embedding 与相关文档 embedding 相似度更高，与无关文档更低。  
   - Loss 常用 InfoNCE、Triplet Loss 或 Margin Ranking Loss。  
   - 数据来源：人工标注的 query–document 对，或用现有搜索引擎生成正负样本。  

2. **知识蒸馏 (Knowledge Distillation)**  
   - 用强大的交叉编码器 (Cross-Encoder) 打分模型作为教师，训练轻量级双塔模型作为学生。  
   - 结合 KD Loss 和对比损失，提升检索效果。  

3. **Hard Negative Mining**  
   - 在训练过程中不断挖掘难区分的负样本，提升检索器的鲁棒性。  

**3. Generator 的微调方式**  
1. **监督微调 (SFT)**  
   - 在检索出的文档 + query 拼接的输入下，训练生成模型输出参考答案。  
   - Loss：交叉熵损失，对齐人工答案。  

2. **指令微调 (Instruction Tuning)**  
   - 构造指令式数据（如“请基于以下资料回答问题”），提升模型遵循 RAG 工作流的能力。  

3. **RLHF / RLAIF**  
   - 奖励函数结合 factuality、引用率、答案完整性，利用强化学习对生成器做进一步对齐。  

4. **对比生成 (Contrastive Generation Fine-tuning)**  
   - 给定多个候选文档，训练模型学会基于相关性更强的文档生成更优回答。  

**4. Retriever 与 Generator 的联合优化**  
- 可以通过 **End-to-End 训练** 或 **Iterative Training**：  
  - 先微调 Retriever，固定后训练 Generator。  
  - 或交替训练：Retriever 提供更好文档 → Generator 产出更好答案 → 反过来再提升 Retriever。  
- 一些研究使用 **联合损失**（retrieval loss + generation loss），实现端到端优化。  

<mark>在 RAG 中，Retriever 通过对比学习、蒸馏和 hard negative mining 来提升检索质量，而 Generator 则通过监督微调、指令微调和 RLHF 来增强答案生成，两者还可以采用联合优化以提升整体性能。</mark>

### Q. RAG管线中，如何动态更新知识库？
**Company**: 蔚来 ｜ **Round**: 算法工程师 一面 ｜ **Date**: 2025-07-15 ｜ **Tags**: [RAG, 知识库, 动态更新]

**1. 背景问题**  
- 在 RAG (Retrieval-Augmented Generation) 系统中，知识库通常存放为 **向量数据库 / 索引**。  
- 实际应用场景中，知识库不是静态的，可能需要频繁加入新文档、更新已有信息或删除过时数据。  
- 关键问题：如何在不完全重建索引的情况下，高效地实现动态更新？

**2. 动态更新的实现方式**  
1. **增量向量化 (Incremental Embedding)**  
   - 新文档到来时，通过相同的 **Embedding 模型** 转换为向量。  
   - 将向量直接插入现有的向量数据库（如 FAISS、Milvus、Weaviate、Pinecone）。  
   - 优点：快速，不需要重建全库。  

2. **索引更新 (Index Update)**  
   - 大多数向量数据库支持 **增删改操作**：  
     - Insert：新文档 embedding 插入。  
     - Update：更新某条记录的 embedding（如文档改动）。  
     - Delete：移除过时文档。  
   - 底层通常通过分片索引 + 定期重建的方式维持效率。  

3. **异步批处理 (Batch Update / Streaming)**  
   - 将新文档放入消息队列（Kafka、RabbitMQ），由异步任务完成 embedding 与写入操作。  
   - 避免在线查询延迟受影响。  

4. **版本化与软更新**  
   - 使用 **文档 ID + 版本号** 机制，新旧 embedding 共存，通过最新版本号来检索。  
   - 可保证回溯性和一致性。  

5. **定期索引重构 (Rebuild / Compact)**  
   - 长期多次增删会导致索引碎片化，影响召回效率。  
   - 需要定期做全量重建或 compact，以保证检索性能。  

**3. 工程注意点**  
- **一致性**：Embedding 模型需固定或版本化，避免新旧 embedding 不可比。  
- **延迟**：更新策略应尽量异步，避免影响查询服务。  
- **数据新鲜度**：根据应用场景（如新闻问答 vs 技术文档），决定是实时更新还是定期批量更新。  
- **监控与回溯**：为每条文档维护时间戳和版本，方便调试与回溯。  

<mark>RAG 管线中知识库的动态更新，通常依赖向量数据库的增删改接口与增量向量化，结合异步批处理和版本化管理，在保证检索性能的同时维持数据新鲜度。</mark>
